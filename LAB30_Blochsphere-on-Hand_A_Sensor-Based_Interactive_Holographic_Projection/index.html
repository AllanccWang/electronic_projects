<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Quantum Qubit 3D Hologram - Measurement Mode</title>
    <style>
        body { margin: 0; background-color: black; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; width: 100vw; }
        
        #hologram-grid {
            position: relative;
            width: 100vw;
            height: 100vw;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
        }

        .view-container { width: 100%; height: 100%; overflow: hidden; display: flex; justify-content: center; align-items: center; }
        
        #view-top    { grid-area: 1 / 2 / 2 / 3; transform: rotate(180deg); }
        #view-left   { grid-area: 2 / 1 / 3 / 2; transform: rotate(90deg); }
        #view-right  { grid-area: 2 / 3 / 3 / 4; transform: rotate(270deg); }
        #view-bottom { grid-area: 3 / 2 / 4 / 3; transform: rotate(0deg); }

        #labels { position: absolute; top: 10px; left: 10px; color: #00ffff; font-family: 'Courier New', monospace; z-index: 10; line-height: 1.5; }
        .equation { font-size: 20px; color: #fff; text-shadow: 0 0 10px #00ffff; }
        .stat-tag { font-size: 12px; color: #555; }
        #msg-box { color: #ff0055; font-weight: bold; font-size: 18px; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="labels">
        <div class="equation" id="dirac">|ψ⟩ = α|0⟩ + β|1⟩</div>
        P(0): <span id="p0">--</span>% | P(1): <span id="p1">--</span>%<br>
        <div id="msg-box"></div>
        <span class="stat-tag">Socket: <span id="status">Connecting...</span></span>
    </div>

    <div id="hologram-grid">
        <div id="view-top" class="view-container"></div>
        <div id="view-left" class="view-container"></div>
        <div id="view-right" class="view-container"></div>
        <div id="view-bottom" class="view-container"></div>
    </div>

    <script>
        let scenes = [], cameras = [], renderers = [], qubitVectors = [];
        const viewIds = ['view-top', 'view-left', 'view-right', 'view-bottom'];
        
        // Quantum state variables
        let isCollapsed = false;
        let lastP0 = 0.5;

        function initHologram() {
            if (typeof THREE === 'undefined') {
                document.getElementById('status').innerText = "ERROR: Three.js not loaded!";
                return;
            }

            const size = window.innerWidth / 3;

            viewIds.forEach((id) => {
                const container = document.getElementById(id);
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
                camera.position.z = 3;

                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(size, size);
                container.appendChild(renderer.domElement);

                // Bloch sphere wireframe
                const sphere = new THREE.Mesh(
                    new THREE.SphereGeometry(1, 16, 16),
                    new THREE.MeshBasicMaterial({ color: 0x004444, wireframe: true, transparent: true, opacity: 0.3 })
                );
                scene.add(sphere);

                // Qubit state vector (initially pointing up to |0⟩)
                const vector = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), 1, 0x00ffff);
                scene.add(vector);

                scenes.push(scene); cameras.push(camera); renderers.push(renderer); qubitVectors.push(vector);
            });
            animate();
            connectWebSocket();
        }

        function animate() {
            requestAnimationFrame(animate);
            // Slowly rotate Bloch spheres for visual effect
            scenes.forEach((scene) => {
                scene.children[0].rotation.y += 0.01; 
            });
            renderers.forEach((r, i) => r.render(scenes[i], cameras[i]));
        }

        function connectWebSocket() {
            const socket = new WebSocket(`ws://192.168.4.1:81`);
            const statusBox = document.getElementById('status');
            const msgBox = document.getElementById('msg-box');

            socket.onopen = () => statusBox.innerText = "Connected";
            
            socket.onmessage = (event) => {
                // 1. Identify measurement command
                if (event.data === "MEASURE") {
                    handleMeasurement();
                    return;
                }

                // If currently displaying collapse result, temporarily ignore position updates
                if (isCollapsed) return;

                const coords = event.data.split(',');
                if (coords.length < 3) return;

                let ax = parseFloat(coords[0]);
                let ay = parseFloat(coords[1]);
                let az = parseFloat(coords[2]);

                // 2. Update 3D qubit vectors in all four views
                let newDir = new THREE.Vector3(ax, az, ay).normalize();
                qubitVectors.forEach(v => v.setDirection(newDir));

                // 3. Update probabilities and Dirac notation
                let p0_val = ((az / 9.8) + 1) / 2;
                lastP0 = Math.max(0, Math.min(1, p0_val)); // Store globally for measurement use
                
                let p0_percent = (lastP0 * 100).toFixed(0);
                let alpha = Math.sqrt(lastP0).toFixed(2);
                let beta = Math.sqrt(1 - lastP0).toFixed(2);

                document.getElementById('p0').innerText = p0_percent;
                document.getElementById('p1').innerText = 100 - p0_percent;
                document.getElementById('dirac').innerText = `|ψ⟩ = ${alpha}|0⟩ + ${beta}|1⟩`;
            };
        }

        function handleMeasurement() {
            isCollapsed = true;
            const msgBox = document.getElementById('msg-box');
            
            // Determine result based on current probability (God plays dice)
            let result = Math.random() < lastP0 ? 0 : 1;
            
            // Visual effect: Force vector to pole position
            let targetDir = result === 0 ? new THREE.Vector3(0, 1, 0) : new THREE.Vector3(0, -1, 0);
            qubitVectors.forEach(v => {
                v.setColor(0xff0055); // Vector turns red during collapse
                v.setDirection(targetDir);
            });

            msgBox.innerText = `MEASURED: |${result}⟩ !`;
            
            // Return to normal after 2 seconds
            setTimeout(() => {
                isCollapsed = false;
                msgBox.innerText = "";
                qubitVectors.forEach(v => v.setColor(0x00ffff));
            }, 2000);
        }

        window.onload = initHologram;
    </script>
</body>
</html>
